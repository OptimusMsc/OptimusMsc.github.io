<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-31T11:14:23+08:00</updated><id>http://localhost:4000/</id><title type="html">Wayne</title><subtitle>Wait me,Big data</subtitle><entry><title type="html">R的常见对象和属性</title><link href="http://localhost:4000/R%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7/" rel="alternate" type="text/html" title="R的常见对象和属性" /><published>2017-08-27T00:00:00+08:00</published><updated>2017-08-27T00:00:00+08:00</updated><id>http://localhost:4000/R%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7</id><content type="html" xml:base="http://localhost:4000/R%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#r中对象的5种基本类型classes-of-objects&quot; id=&quot;markdown-toc-r中对象的5种基本类型classes-of-objects&quot;&gt;R中对象的5种基本类型(classes of objects)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#r中的赋值符号为-&quot; id=&quot;markdown-toc-r中的赋值符号为-&quot;&gt;R中的赋值符号为&amp;lt;-&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#查看变量的值的方法&quot; id=&quot;markdown-toc-查看变量的值的方法&quot;&gt;查看变量的值的方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#查看对象的类型&quot; id=&quot;markdown-toc-查看对象的类型&quot;&gt;查看对象的类型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#r中对象的属性attribute&quot; id=&quot;markdown-toc-r中对象的属性attribute&quot;&gt;R中对象的属性(attribute)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;r中对象的5种基本类型classes-of-objects&quot;&gt;R中对象的5种基本类型(classes of objects)&lt;/h2&gt;
&lt;p&gt;– 字符(character)&lt;br /&gt;
– 数值(numeric:real numbers)&lt;br /&gt;
– 整数(integer)&lt;br /&gt;
– 复数(complex):1+2i&lt;br /&gt;
– 逻辑(logical:True/False)&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;r中的赋值符号为-&quot;&gt;R中的赋值符号为&amp;lt;-&lt;/h3&gt;
&lt;p&gt; 例如，想新建一个值为1的变量x，则输入x&amp;lt;-1，回车即可&lt;br /&gt;
 创建字符型变量，y&amp;lt;-“hello world”&lt;br /&gt;
 创建逻辑型变量，t&amp;lt;-TRUE，需要注意的是，R中的TRUE和FALSE要全部大写&lt;br /&gt;
 创建复数型变量，x&amp;lt;-1+2i&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看变量的值的方法&quot;&gt;查看变量的值的方法&lt;/h3&gt;
&lt;p&gt; 输入变量名，回车即可&lt;br /&gt;
 例如：输入x，回车，则会显示[1] 1.其中[]中的1代表后面所接的元素，是x中的第1个元素；没有[]的1代表x中存储的内容为1&lt;br /&gt;
 &lt;em&gt;右侧Global Environment中也会显示变量名和对应的值&lt;/em&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看对象的类型&quot;&gt;查看对象的类型&lt;/h3&gt;
&lt;p&gt; 使用class()函数&lt;br /&gt;
 例如：输入class(x)，回车，则可以看到x的类型为”numeric”&lt;br /&gt;
 如果想强调变量类型为整数，则只需要在赋值的时候，在数字后面加上L(大写)，例如：x&amp;lt;-2L，此时class(x)会显示为”integer”&lt;br /&gt;
&lt;strong&gt;tips:&lt;br /&gt;
 1.如果用”=”代替”&amp;lt;-“，在99%的情况下都不会报错，但是某些及端情况会出错，所以应该尽可能使用标准赋值符号”&amp;lt;-“&lt;br /&gt;
 2.R是大小写敏感的语言，x和X会代表不同的变量，注意区分大小写&lt;br /&gt;&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;r中对象的属性attribute&quot;&gt;R中对象的属性(attribute)&lt;/h2&gt;
&lt;p&gt;– 名称(name)&lt;br /&gt;
– 维度(dimensions:matrix,array)&lt;br /&gt;
– 类型(class)&lt;br /&gt;
– 长度(length)&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><category term="大数据" /><category term="R" /><category term="对象和属性" /><summary type="html"></summary></entry><entry><title type="html">R的安装与帮助</title><link href="http://localhost:4000/R%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%AE%E5%8A%A9/" rel="alternate" type="text/html" title="R的安装与帮助" /><published>2017-08-20T00:00:00+08:00</published><updated>2017-08-20T00:00:00+08:00</updated><id>http://localhost:4000/R%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%AE%E5%8A%A9</id><content type="html" xml:base="http://localhost:4000/R%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%AE%E5%8A%A9/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#r的获取与安装&quot; id=&quot;markdown-toc-r的获取与安装&quot;&gt;R的获取与安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rstudio的获取与安装&quot; id=&quot;markdown-toc-rstudio的获取与安装&quot;&gt;RStudio的获取与安装&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#r中的包package&quot; id=&quot;markdown-toc-r中的包package&quot;&gt;R中的包(package)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#扩展r基本功能的机制集成了众多函数&quot; id=&quot;markdown-toc-扩展r基本功能的机制集成了众多函数&quot;&gt;扩展R基本功能的机制/集成了众多函数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#通常在cranbioconductorgithub等上面获取包&quot; id=&quot;markdown-toc-通常在cranbioconductorgithub等上面获取包&quot;&gt;通常在CRAN/Bioconductor/GitHub等上面获取包&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#获取帮助&quot; id=&quot;markdown-toc-获取帮助&quot;&gt;获取帮助&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#函数名r的帮助文档&quot; id=&quot;markdown-toc-函数名r的帮助文档&quot;&gt;?函数名(R的帮助文档)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#googlestackoverflow&quot; id=&quot;markdown-toc-googlestackoverflow&quot;&gt;Google/Stackoverflow&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#如何问问题&quot; id=&quot;markdown-toc-如何问问题&quot;&gt;如何问问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;r的获取与安装&quot;&gt;R的获取与安装&lt;/h2&gt;

&lt;p&gt;R的下载地址:cran.r-project.org&lt;br /&gt;
Windows操作系统下，选择“Download R for Windows”，然后选择“base”，会显示当前R的最新版本，点击下载&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;rstudio的获取与安装&quot;&gt;RStudio的获取与安装&lt;br /&gt;&lt;/h2&gt;
&lt;p&gt;RStudio的下载地址:rstudio.com&lt;br /&gt;
在RStudio模块下点击Download，进入版本类型界面，选择RStudio Desktop，然后根据系统版本选择对应的安装程序进行下载&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;r中的包package&quot;&gt;R中的包(package)&lt;/h2&gt;
&lt;h3 id=&quot;扩展r基本功能的机制集成了众多函数&quot;&gt;扩展R基本功能的机制/集成了众多函数&lt;/h3&gt;
&lt;h3 id=&quot;通常在cranbioconductorgithub等上面获取包&quot;&gt;通常在CRAN/Bioconductor/GitHub等上面获取包&lt;/h3&gt;
&lt;p&gt;– 直接在RStudio的命令行中输入以下代码即可安装包&lt;br /&gt;
 install.packages(“包名”)  //在CRAN上获取包&lt;br /&gt;
 install_github()  //在GitHub上获取包&lt;br /&gt;
 例如:安装机器学习需要用到的包caret,打开RStudio，在命令行中输入install.packages(“caret”)，键入回车即可&lt;br /&gt;
– 安装完之后，使用包内的函数之前，需要加载对应的包，加载的代码为library(包名)&lt;br /&gt;
 例如:library(caret)&lt;br /&gt;
– tips:当包加载完之后，直接在命令行输入data()，回车，就能打开包中所有所含函数集的详细信息;&lt;br /&gt;
 如果想查看某一个数据集的具体信息，只需在命令行中输入 ?数据集名称 ，即可。&lt;br /&gt;
 例如?InsectSprays,即(帮助文档)可查看InsectSprays数据集的详细信息(帮助文档)&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取帮助&quot;&gt;获取帮助&lt;/h2&gt;
&lt;h3 id=&quot;函数名r的帮助文档&quot;&gt;?函数名(R的帮助文档)&lt;/h3&gt;
&lt;h3 id=&quot;googlestackoverflow&quot;&gt;Google/Stackoverflow&lt;/h3&gt;
&lt;h3 id=&quot;如何问问题&quot;&gt;如何问问题&lt;/h3&gt;
&lt;p&gt;- 操作系统、版本、哪一步产生的错误、预期是什么、得到的结果是什么、其他有用的信息&lt;br /&gt;
- 例如:Win7 R 3.2.0 lm()  “seg fault on large data frame”&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><category term="大数据" /><category term="R" /><category term="环境配置" /><summary type="html"></summary></entry><entry><title type="html">继承</title><link href="http://localhost:4000/%E7%BB%A7%E6%89%BF/" rel="alternate" type="text/html" title="继承" /><published>2017-07-31T20:10:00+08:00</published><updated>2017-07-31T20:10:00+08:00</updated><id>http://localhost:4000/%E7%BB%A7%E6%89%BF</id><content type="html" xml:base="http://localhost:4000/%E7%BB%A7%E6%89%BF/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1原型链&quot; id=&quot;markdown-toc-1原型链&quot;&gt;1、原型链&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2借用构造函数&quot; id=&quot;markdown-toc-2借用构造函数&quot;&gt;2、借用构造函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3组合继承&quot; id=&quot;markdown-toc-3组合继承&quot;&gt;3、组合继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4原型式继承&quot; id=&quot;markdown-toc-4原型式继承&quot;&gt;4、原型式继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5寄生式继承&quot; id=&quot;markdown-toc-5寄生式继承&quot;&gt;5、寄生式继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6寄生组合式继承&quot; id=&quot;markdown-toc-6寄生组合式继承&quot;&gt;6、寄生组合式继承&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;继承是面向对象程序设计中最常见的一个概念，许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只能继承方法签名，而实现继承则继承实际的方法。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;

&lt;h3 id=&quot;1原型链&quot;&gt;1、原型链&lt;/h3&gt;
&lt;p&gt;原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;br /&gt;
构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。&lt;br /&gt;
实现原型链的基本模式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){        //被继承的函数叫做超类型（父类，基类）
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
};
function SubType(){        //继承的函数叫做子类型（子类，派生类）
	this.subproperty = false;
}
//继承了SuperType
SubType.prototype = new SuperType(); //通过原型链继承，超类型实例化后的对象实例，赋值给子类型的原型属性。
SubType.prototype.getSubValue = function(){
	return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原型链虽然很强大，可以用它来实现继承，但也存在一些问题，最主要的问题来自包含引用类型值的原型，包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。如下面这个例子所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
function SubType(){
}
SubType.prototype = new SuperType();
var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance.colors);   //&quot;red,blue,green,black&quot;
var instance2 = new SubType();
alert(instance2.colors);  //&quot;red,blue,green,black&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2借用构造函数&quot;&gt;2、借用构造函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
function SubType(){
	SuperType.call(this); //继承了SuperType
}
var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
var instance2 = new SubType();
alert(instance2.colors);  //&quot;red,blue,green&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这段代码中，SuperType.call(this)这行代码“借调”了超类型的构造函数，通过使用call()方法（或apply()方法），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数，这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每一个实例就会有自己的colors属性的副本了。&lt;/p&gt;

&lt;h3 id=&quot;3组合继承&quot;&gt;3、组合继承&lt;/h3&gt;
&lt;p&gt;组合继承也称伪经典继承，指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(name){
	this.name = name;
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
SuperType.prototype.sayName = function(){
	alert(this.name);
};
function SubType(name,age){
	//继承属性
	SuperType.call(this,name);
	this.age = age;
}
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
  alert(this.age);
};
var instance1 = new SubType(&quot;Nicholas&quot;,29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);           //&quot;red,blue,green,black&quot;
instance1.sayName();               //&quot;Nicholas&quot;
instance1.sayAge();                //&quot;29&quot;
var instance2 = new SubType(&quot;Greg&quot;,27);
alert(instance2.colors);           //&quot;red,blue,green&quot;
instance1.sayName();               //&quot;Greg&quot;
instance2.satAge();                //27
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4原型式继承&quot;&gt;4、原型式继承&lt;/h3&gt;
&lt;p&gt;原型式继承并没有使用严格意义上的构造函数，它借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型，为了达到这个目的，出现了以下函数：&lt;br /&gt;
临时中转函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function object(o){   //o表示将要传递进入的一个对象
   function F(){}     //F构造是一个临时新建的对象，用来存储传递过来的对象
   F.prototype = o;   //将o的对象实例赋值给F构造的原型对象
   return new F();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从本质上讲，object()对传入其中的对象执行了一次浅复制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var person = {
	name: &quot;Nicholas&quot;,
	friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = object(person);
anotherPerson.name = &quot;Greg&quot;;
anotherPerson.friends.push(&quot;Rob&quot;);

var yetAnotherPerson = object(person);
yetAnotherPerson.name = &quot;Linda&quot;;
yetAnotherPerson.friends.push(&quot;Barbie&quot;);

alert(person.friends);    //&quot;Shelby,Court,Van,Rob,Barbie&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这个例子中，可以作为另一个对象基础的是person对象，我们将它传入到object()函数中，然后该函数就会返回一个新对象，这个对象将person作为原型，所以它的原型中就会包含一个基本类型值属性和一个引用类型值属性，这就意味着person.friends不仅属于person，而且也会被anotherPerson以及yetAnotherPerson共享，这就相当于又创建了person对象的两个副本。&lt;/p&gt;

&lt;h3 id=&quot;5寄生式继承&quot;&gt;5、寄生式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function createAnother(original){
	var clone = object(original);      //通过调用函数创建一个新对象
	clone.sayHi = function(){          //以某种方式来增强这个对象
		alert(&quot;hi&quot;);
	};
	return clone;                      //返回这个对象
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这段代码中，createAnother()函数接收了一个参数，也就是要作为新对象基础的对象，然后把这个对象(original)传递给object()函数，将返回到结果赋值给clone。再为clone对象添加一个新方法sayHi()，最后返回clone对象。可以像下面这这样来使用createAnother()函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var person = {
	name = &quot;Nicholas&quot;,
	friends : [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();   //&quot;hi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6寄生组合式继承&quot;&gt;6、寄生组合式继承&lt;/h3&gt;
&lt;p&gt;组合继承最大的问题是无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(name){
	this.name = name;
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
SuperType.prototype.sayName = function(){
	alert(this.name);
};
function SubType(name,age){
	SuperType.call(this,name);            //第二次调用SuperType()，在新对象上创建了实例属性：name,colors
	this.age = age;
}
SubType.prototype = new SuperType();     //第一次调用SuperType(),SubType的原型会得到两个属性：name,colors
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
	alert(this.age);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要解决上面例子中的两次调用超类型函数的问题，就出现了寄生组合式继承的方法。寄生组合式继承本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型，基本模式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function inheritPrototype(subType,superType){
	var prtotype = object(superType.prototype);   //创建对象
	prototype.constructor = subType;              //增强对象
	subType.prototype = prototype;                //指定对象
} 实现寄生组合继承的基本步骤是：&amp;lt;br&amp;gt; 第一步是创建超类型原型的一个副本；&amp;lt;br&amp;gt; 第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性；&amp;lt;br&amp;gt; 第三步是将新创建的对象（即副本）赋值给子类型的原型。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name></name></author><category term="JS" /><summary type="html"></summary></entry><entry><title type="html">JavaScript变量、作用域和内存问题</title><link href="http://localhost:4000/JavaScript%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="JavaScript变量、作用域和内存问题" /><published>2017-02-16T09:20:00+08:00</published><updated>2017-02-16T09:20:00+08:00</updated><id>http://localhost:4000/JavaScript%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/JavaScript%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#基本内容&quot; id=&quot;markdown-toc-基本内容&quot;&gt;基本内容&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#预加载变量提升&quot; id=&quot;markdown-toc-预加载变量提升&quot;&gt;预加载、变量提升&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基本内容&quot;&gt;基本内容&lt;/h2&gt;

&lt;p&gt;1、ECMAScript变量包含两种类型的值：基本类型值和引用类型值。&lt;br /&gt;
2、JavaScript变量为松散类型，松散类型变量的特点就是定义的时候不给它指定类型，变量在运行的时候可以随便改变数据类型。&lt;br /&gt;
3、执行环境及作用域&lt;br /&gt;
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
每个函数都有自己的执行环境。当执行流进入下一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。
当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。&lt;/p&gt;

&lt;p&gt;示例代码1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var color = &quot;blue&quot;;  
function changeColor(){  
  if(color===&quot;blue&quot;){  
    color=&quot;red&quot;;  
    }else{  
     color=&quot;blue&quot;;  
    }  
}  
changeColor();  
console.log(&quot;Color is now&quot;+color);   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果：Color is now red&lt;br /&gt;
在上面这个例子中，变量color为全局环境的变量对象，在作用域链中可以找到它，所以在函数内部可以访问变量color，执行if语句，color变成red。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;示例代码2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var color = &quot;blue&quot;;  
function changeColor(){  
var anotherColor = &quot;red&quot;;  
function swapColors(){  
  var tempColor = anotherColor;  
  anotherColor = color;  
  color = tempColor;  
  //这里可以访问color、anotherColor和tempColor
}  
//这里可以访问color和anotherColor,但不能访问tempColor  
  swapColors();  
}  
//这里只能访问color  
changeColor();  
console.log(&quot;color is now &quot;+ color);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果：color is now red&lt;br /&gt;
在上面这个例子中，涉及三个执行环境，：全局环境、changeColor()的局部环境和swapColor()的局部环境，全局环境中有一个变量color和changeColor()函数，changeColor()局部环境中有一个变量anotherColor和swapColors()函数，但是可以访问变量color,swapColors()局部环境中包含一个变量tempColor，但是可以访问变量color和变量anotherColor。
这段代码环境的作用域链如下图所示
&lt;img src=&quot;/styles/images/JavaScript变量、作用域和内存问题/zuoyongyu.png&quot; alt=&quot;/styles/images/JavaScript变量、作用域和内存问题/zuoyongyu.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在执行环境中，内部环境可以通过作用域链访问外部环境的变量和函数，但是外部环境不能访问内部环境的变量和函数，每个环境只能向上搜索作用域链。&lt;/p&gt;

&lt;h2 id=&quot;预加载变量提升&quot;&gt;预加载、变量提升&lt;/h2&gt;
&lt;p&gt;javascript语言的松散类型的特点以及运行时候随时更改变量类型的特点，很多程序员会认为javascript变量的定义是在运行期进行的，更有甚者有些人认为javascript代码只有运行期，其实这种理解是错误的，javascript代码在运行前还有一个过程就是：预加载，预加载的目的是要事先构造运行环境例如全局环境，函数运行环境，还要构造作用域链，而环境和作用域的构造的核心内容就是指定好变量属于哪个范畴，因此在javascript语言里变量的定义是在预加载完成而非在运行时期。&lt;br /&gt;
JavaScript引擎的工作方式是先解析代码，获取所有被声明的变量，然后再一行一行的运行，这造成的结果，就是所有变量的声明语句都会被提升到代码的头部，这就叫做变量提升。
例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1;  
function test(){  
  console.log(a);//undefined  
  var a = 2;  
  console.log(a);//2  
}  
test();  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这段代码在函数的局部作用域下变量a被重新定义了，在预加载时候a的作用域范围也就被框定了，a变量不再属于全局变量，而是属于函数作用域，只不过赋值操作是在运行期执行（这就是为什么javascript语言在运行时候会改变变量的类型，因为赋值操作是在运行期进行的），所以第一次使用a变量时候，a变量在局部作用域里没有被赋值，只有栈区的标示名称，因此结果就是undefined了。（这也就是js里的变量提升的原理）&lt;/p&gt;</content><author><name></name></author><category term="JS" /><summary type="html"></summary></entry></feed>